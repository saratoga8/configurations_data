Using expressions in string: #{...}
Array of words: a = %{ ant bee cat dog elk }
Unpredeclared constants: :some_const
Instead (0..6) use 7.times
Code block: { puts "here" } then called by yield
iterator: code called by yield for each element
& - for passing block as param. e.g. 
            def with_tmp_dir(&block)
              Dir.mktmpdir do |tmp_dir|
                Dir.chdir(tmp_dir, &block)
              end
            end
lambda { |params| ... } or -> (par1, par2) { ... } - storing block in var 
<=> - return 0, 1, -1
.eql? - as ==, but used in Hash too, and use type compare: 1 eql? 1.0 => false
.equal? - objects ids R equals
a, b, c = 0, 2, 3
1...10 - from 1 to 9
(1..10) === 5 - true; (1..10) === 15 - false
return 3, 4 - returns [3, 4]
def foo(a, b) puts a, b end - foo(*[a, b, c, d]) will print "a, b"
all !nil and !false == true  (zero, 0 == true)
var ||= val - set val to var if it isn't set yet
ensure - code after exception(occured or nod)
@@class_const
def foo(a, b*, c) - b will be array
lambda vs proc: 
  -> {return} - return from closure
  proc {return} - return from outside closure too
alias: alias for method, alias_method if scope is important
use string key in hash: hash[key.to_sym]
Hash.new("new default") - change default key of hash from nil
dynamic default key - Hash.new { |hash, key| "#{key}: #{ Time.now.to_i }" }
chage default after defined - h = {}; h.default = "default" or h.default_proc = Proc.new { Time.now.to_i }
names.map(&:upcase)     instead        names.map { |name| name.upcase }
hash as optional params:             def greeting(name, options = {})
                                     greeting("Bob", age: 62, city: "New York City")
include - can use included in a built instance of a class: SomeClass.new.module_func
extend - can use extended in a class: SomeClass::module_func
#each - execute on each and return unaffected arr
#map - execute on each and return new arr
