Using expressions in string: #{...}
Array of words: a = %{ ant bee cat dog elk }
Unpredeclared constants: :some_const
Instead (0..6) use 7.times
Code block: { puts "here" } then called by yield
iterator: code called by yield for each element
& - for passing block as param
lambda { |params| ... } or -> (par1, par2) { ... } - storing block in var 
<=> - return 0, 1, -1
.eql? - as ==, but used in Hash too, and use type compare: 1 eql? 1.0 => false
.equal? - objects ids R equals
a, b, c = 0, 2, 3
1...10 - from 1 to 9
(1..10) === 5 - true; (1..10) === 15 - false
return 3, 4 - returns [3, 4]
def foo(a, b) puts a, b end - foo(*[a, b, c, d]) will print "a, b"
all !nil and !false == true  (zero, 0 == true)
var ||= val - set val to var if it isn't set yet
ensure - code after exception(occured or nod)
@@class_const
def foo(a, b*, c) - b will be array
lambda vs proc: 
  -> {return} - return from closure
  proc {return} - return from outside closure too
alias: alias for method, alias_method if scope is important
use string key in hash: hash[key.to_sym]
